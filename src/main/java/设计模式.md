# 1. 引入
## 1.1 使用设计模式的目的
它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路。

其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。
## 1.2 设计模式抽象
模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。
## 1.3 设计模式分类
[http://c.biancheng.net/view/1320.html](http://c.biancheng.net/view/1320.html)
## 1.4 面向对象设计原则
1. 开闭原则：软件实体应该对扩展开放、对修改关闭。
2. 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。
3. 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。面向接口编程，不要面向实现编程。
4. 单一职责原则：一个类应该有且仅有一个引起它变化的原因。
5. 接口隔离原则：将庞大臃肿的接口拆成更小的、更具体的接口，让接口中只包含客户感兴趣的方法。
6. 迪米特法则：只与你的直接朋友交谈，不跟陌生人讲话。如，尽量降低类成员的访问权限；不暴露类的属性成员，应该提供相应的访问器。
7. 合成复用原则：在软件复用时，尽量先使用组合、聚合等关联关系来实现，其次才考虑使用继承关系实现。

> 开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；  
> 里氏替换原则告诉我们不要破坏继承体系；  
> 依赖倒置原则告诉我们要面向接口编程；  
> 单一职责原则告诉我们实现类要职责单一；  
> 接口隔离原则告诉我们在设计接口时要精简单一；  
> 迪米特法则告诉我们要降低耦合度；  
> 合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
# 2. 创建型模式
创建型模式分为以下几种：
1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
## 2.1 单例模式
## 2.2 原型模式
原型（Prototype）模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。

Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆。

代码示例：

![https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java)

浅拷贝不拷贝引用对象：

![https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java)