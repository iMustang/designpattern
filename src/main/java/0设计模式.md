# 1. 引入
## 1.1 使用设计模式的目的
它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路。

其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。
## 1.2 设计模式抽象
模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。
## 1.3 设计模式分类
[http://c.biancheng.net/view/1320.html](http://c.biancheng.net/view/1320.html)
## 1.4 面向对象设计原则
1. 开闭原则：软件实体应该对扩展开放、对修改关闭。
2. 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。
3. 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。面向接口编程，不要面向实现编程。
4. 单一职责原则：一个类应该有且仅有一个引起它变化的原因。
5. 接口隔离原则：将庞大臃肿的接口拆成更小的、更具体的接口，让接口中只包含客户感兴趣的方法。
6. 迪米特法则：只与你的直接朋友交谈，不跟陌生人讲话。如，尽量降低类成员的访问权限；不暴露类的属性成员，应该提供相应的访问器。
7. 合成复用原则：在软件复用时，尽量先使用组合、聚合等关联关系来实现，其次才考虑使用继承关系实现。

> 开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；  
> 里氏替换原则告诉我们不要破坏继承体系；  
> 依赖倒置原则告诉我们要面向接口编程；  
> 单一职责原则告诉我们实现类要职责单一；  
> 接口隔离原则告诉我们在设计接口时要精简单一；  
> 迪米特法则告诉我们要降低耦合度；  
> 合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
# 2. 创建型模式
创建型模式分为以下几种：
1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
## 2.1 单例模式
[https://github.com/iMustang/designpattern/blob/master/src/main/java/singleton/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/singleton/Main.java)

单例模式可扩展为有限的多例（Multitcm）模式。
## 2.2 原型模式
原型（Prototype）模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。

Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆。

代码示例：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java)

浅拷贝不拷贝引用对象：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java)

深拷贝：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/deepclone/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/deepclone/Main.java)

原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。
## 2.3 工厂方法模式
工厂方法（FactoryMethod）模式：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。

工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/factorymethod/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/factorymethod/Main.java)

当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/simplefactroy/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/simplefactroy/Main.java)
## 2.4 抽象工厂模式
将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。抽象工厂模式考虑多等级产品的生产。

产品等级、产品族见下图：

![产品等级、产品族](https://github.com/iMustang/designpattern/blob/master/src/main/resources/%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E4%BA%A7%E5%93%81%E6%97%8F.gif?raw=true)

[https://github.com/iMustang/designpattern/blob/master/src/main/java/abstractfactory/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/abstractfactory/Main.java)
## 2.5 建造者模式
建造者（Builder）模式：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

它将变与不变分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/builder/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/builder/Main.java)
# 3. 结构型模式
结构型模式描述如何将类或对象按某种布局组成更大的结构。

它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

结构型模式分为以下7种：
- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
- 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。

## 3.1 代理模式
![https://github.com/iMustang/designpattern/blob/master/src/main/java/proxy/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/proxy/Main.java)

## 3.2 适配器模式
适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

适配器模式（Adapter）通常适用于以下场景。
1. 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
2. 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/forobj/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/forobj/Main.java)

![https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/Main.java)
## 3.3 桥接模式
桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

