# 1. 引入
## 1.1 使用设计模式的目的
它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路。

其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。
## 1.2 设计模式抽象
模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。
## 1.3 设计模式分类
[http://c.biancheng.net/view/1320.html](http://c.biancheng.net/view/1320.html)
## 1.4 面向对象设计原则
1. 开闭原则：软件实体应该对扩展开放、对修改关闭。
2. 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。
3. 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。面向接口编程，不要面向实现编程。
4. 单一职责原则：一个类应该有且仅有一个引起它变化的原因。
5. 接口隔离原则：将庞大臃肿的接口拆成更小的、更具体的接口，让接口中只包含客户感兴趣的方法。
6. 迪米特法则：只与你的直接朋友交谈，不跟陌生人讲话。如，尽量降低类成员的访问权限；不暴露类的属性成员，应该提供相应的访问器。
7. 合成复用原则：在软件复用时，尽量先使用组合、聚合等关联关系来实现，其次才考虑使用继承关系实现。

> 开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；  
> 里氏替换原则告诉我们不要破坏继承体系；  
> 依赖倒置原则告诉我们要面向接口编程；  
> 单一职责原则告诉我们实现类要职责单一；  
> 接口隔离原则告诉我们在设计接口时要精简单一；  
> 迪米特法则告诉我们要降低耦合度；  
> 合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
# 2. 创建型模式
创建型模式分为以下几种：
1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
## 2.1 单例模式
[https://github.com/iMustang/designpattern/blob/master/src/main/java/singleton/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/singleton/Main.java)

单例模式可扩展为有限的多例（Multitcm）模式。
## 2.2 原型模式
原型（Prototype）模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。

Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆。

代码示例：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/RealizeTypeTest.java)

浅拷贝不拷贝引用对象：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/Main.java)

深拷贝：

[https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/deepclone/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/prototype/deepclone/Main.java)

原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。
## 2.3 工厂方法模式
工厂方法（FactoryMethod）模式：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。

工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/factorymethod/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/factorymethod/Main.java)

当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/simplefactroy/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/simplefactroy/Main.java)
## 2.4 抽象工厂模式
将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。抽象工厂模式考虑多等级产品的生产。

产品等级、产品族见下图：

![产品等级、产品族](https://github.com/iMustang/designpattern/blob/master/src/main/resources/%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E4%BA%A7%E5%93%81%E6%97%8F.gif?raw=true)

[https://github.com/iMustang/designpattern/blob/master/src/main/java/abstractfactory/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/abstractfactory/Main.java)
## 2.5 建造者模式
建造者（Builder）模式：将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

它将变与不变分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

[https://github.com/iMustang/designpattern/blob/master/src/main/java/builder/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/builder/Main.java)
# 3. 结构型模式
结构型模式描述如何将类或对象按某种布局组成更大的结构。

它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

结构型模式分为以下7种：
- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
- 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。

## 3.1 代理模式
![https://github.com/iMustang/designpattern/blob/master/src/main/java/proxy/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/proxy/Main.java)

## 3.2 适配器模式
适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

适配器模式（Adapter）通常适用于以下场景。
1. 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
2. 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/forobj/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/forobj/Main.java)

![https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/adapter/Main.java)
## 3.3 桥接模式
桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/bridge/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/bridge/Main.java)
## 3.4 装饰模式
装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/decorator/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/decorator/Main.java)
## 3.5 外观模式
外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

外观（Facade）模式是“迪米特法则”的典型应用。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/facade/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/facade/Main.java)
## 3.6 享元模式
享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/flyweight/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/flyweight/Main.java)
## 3.7 组合模式
组合（Composite）模式的定义：它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/composite/transparent/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/composite/transparent/Main.java)
# 4. 行为型模式
行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

它包含以下 11 种模式。
1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。
## 4.1 模板方法模式
模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

1. 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。
- 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
- 基本方法：是整个算法中的一个步骤，包含以下几种类型。
    1. 抽象方法：在抽象类中申明，由具体子类实现。
    2. 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
    3. 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。
2. 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/template/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/template/Main.java)
## 4.2 策略模式
策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。

策略模式的重心不是如何实现算法，而是如何组织这些算法。

策略模式的主要优点如下：
1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/strategy/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/strategy/Main.java)
## 4.3 命令模式
命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。

命令模式通常适用于以下场景：
1. 当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。
2. 当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。
3. 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
4. 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/command/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/command/Main.java)
## 4.4 责任链模式
责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

职责链模式主要包含以下角色：
1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

![https://github.com/iMustang/designpattern/blob/master/src/main/java/responsibilitychain/Main.java](https://github.com/iMustang/designpattern/blob/master/src/main/java/responsibilitychain/Main.java)
## 4.5 状态模式
